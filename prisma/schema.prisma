// 1. Define your database connection
datasource db {
  provider = "postgresql" // <-- CHANGED to postgresql
  url      = env("DATABASE_URL")
}

// 2. Define your "generator" (Prisma Client)
generator client {
  provider = "prisma-client-js"
}

// 3. Define your Enums for validation
enum AccountStatus {
  pending_verification
  active
  suspended
}

enum SubscriptionStatus {
  trialing
  active
  past_due
  canceled
}

enum BillingCycle {
  monthly
  yearly
  one_time
}

enum ApiKeyStatus {
  active
  revoked
}

// 4. Define your Models (Tables)
model User {
  id              Int     @id @default(autoincrement())
  name            String  @db.VarChar(100)
  username        String  @unique @db.VarChar(50)
  email           String  @unique @db.VarChar(100)
  password        String  @db.VarChar(255) 
  accountStatus   AccountStatus @default(pending_verification)
  customerId      String? @db.VarChar(255) 
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // --- Relations ---
  
  // The user's CURRENT active subscription
  currentSubscriptionId Int?                 @unique
  currentSubscription   UserSubscription?    @relation("UserSubscriptions", fields: [currentSubscriptionId], references: [id], onUpdate: NoAction, onDelete: NoAction)
  
  // A user can have MANY subscriptions over time (history)
  subscriptions         UserSubscription[]   @relation("UserSubscriptionHistory")
  
  // A user can have MANY API keys
  apiKeys               ApiKey[]
  
  // A user has MANY usage logs
  usageLogs             ApiUsageLog[]
}

model Admin {
  id        Int      @id @default(autoincrement())
  name      String   @db.VarChar(100)
  username  String   @unique @db.VarChar(50)
  email     String   @unique @db.VarChar(100)
  password  String   @db.VarChar(255)
  role      String   @default("admin") @db.VarChar(50)
  createdAt DateTime @default(now())
}

model GeminiApiKey {
  id            Int      @id @default(autoincrement())
  key           String   @unique @db.VarChar(255)
  requestCount  Int      @default(0)
  isRateLimited Boolean  @default(false)
  lastUsedAt    DateTime @default(now())
  createdAt     DateTime @default(now())

  @@index([isRateLimited, requestCount])
}

model ApiKey {
  id        Int          @id @default(autoincrement())
  name      String       @db.VarChar(100)
  keyPrefix String       @db.VarChar(30)
  keyHash   String       @unique @db.VarChar(255)
  status    ApiKeyStatus @default(active)
  lastUsedAt DateTime?
  createdAt DateTime     @default(now())
  
  // --- Relations ---
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  
  // This key has MANY usage logs
  usageLogs ApiUsageLog[]
  
  @@index([userId])
}

model SubscriptionPlan {
  id                  Int      @id @default(autoincrement())
  name                String   @db.VarChar(100)
  planProviderId      String   @unique @db.VarChar(255) 
  priceCents          Int      @default(0)
  billingCycle        BillingCycle
  requestLimitMonthly Int
  rateLimitPerMinute  Int
  features            Json? 
  isPublic            Boolean  @default(true)
  
  // --- Relations ---
  // Many subscriptions can be on this one plan
  subscriptions       UserSubscription[]
}

model UserSubscription {
  id                   Int                @id @default(autoincrement())
  status               SubscriptionStatus
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  
  // --- Relations ---
  user                 User               @relation("UserSubscriptionHistory", fields: [userId], references: [id])
  userId               Int
  
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
  planId               Int
  
  // This is the "one-to-one" link back to the user's *current* plan
  activeUser           User?              @relation("UserSubscriptions")
  
  @@index([userId])
  @@index([planId])
}

model ApiUsageLog {
  id                BigInt   @id @default(autoincrement())
  requestTimestamp  DateTime @default(now())
  httpMethod        String   @db.VarChar(10)
  endpoint          String   @db.VarChar(255)
  httpStatusCode    Int
  responseTimeMs    Int
  creditsConsumed   Int      @default(1)
  
  // --- Relations ---
  user              User     @relation(fields: [userId], references: [id])
  userId            Int
  
  apiKey            ApiKey   @relation(fields: [apiKeyId], references: [id])
  apiKeyId          Int
  
  // --- Indexes for fast quota lookups ---
  @@index([userId, requestTimestamp])
  @@index([apiKeyId, requestTimestamp])
}